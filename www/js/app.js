// Generated by CoffeeScript 1.6.2
(function() {
  var namespace,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  namespace = function(target, name, block) {
    var item, top, _i, _len, _ref, _ref1;
    if (arguments.length < 3) {
      _ref = [(typeof exports !== 'undefined' ? exports : window)].concat(__slice.call(arguments)), target = _ref[0], name = _ref[1], block = _ref[2];
    }
    top = target;
    _ref1 = name.split('.');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      target = target[item] || (target[item] = {});
    }
    return block(target, top);
  };

  namespace('tictactoe.helpers', function(exports) {
    return exports.randomChoice = function(sequence) {
      var index;
      index = Math.floor(Math.random() * sequence.length);
      return sequence[index];
    };
  });

  namespace('tictactoe', function(exports) {
    var Event;
    return exports.Event = Event = (function() {
      function Event() {
        this.callbacks = [];
      }

      Event.prototype.add = function(callback) {
        return this.callbacks.push(callback);
      };

      Event.prototype.remove = function(callback) {
        var i;
        i = this.callbacks.indexOf(callback);
        if (i > -1) {
          return this.callbacks.splice(i, 1);
        }
      };

      Event.prototype.raise = function(sender, args) {
        var callback, _i, _len, _ref, _results;
        _ref = this.callbacks;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          _results.push(callback(sender, args));
        }
        return _results;
      };

      return Event;

    })();
  });

  namespace('tictactoe', function(exports) {
    var Mark;
    return exports.Mark = Mark = (function() {
      function Mark() {}

      Mark.X = -1;

      Mark.EMPTY = 0;

      Mark.O = 1;

      Mark.VALID_MARKS = [Mark.X, Mark.O];

      Mark.getOpponent = function(mark) {
        if (!(__indexOf.call(Mark.VALID_MARKS, mark) >= 0)) {
          throw new Error("Invalid mark");
        }
        return -mark;
      };

      Mark.toString = function(mark) {
        if (!(__indexOf.call(Mark.VALID_MARKS, mark) >= 0)) {
          throw new Error("Invalid mark");
        }
        if (mark === Mark.X) {
          return 'X';
        } else {
          return 'O';
        }
      };

      return Mark;

    })();
  });

  namespace('tictactoe', function(exports) {
    var Player;
    return exports.Player = Player = (function() {
      function Player() {}

      Player.HUMAN = 0;

      Player.COMPUTER = 1;

      Player.VALID_PLAYERS = [Player.HUMAN, Player.COMPUTER];

      return Player;

    })();
  });

  namespace('tictactoe', function(exports) {
    var Board;
    return exports.Board = Board = (function() {
      Board.WIN_POSITIONS = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];

      function Board(board) {
        var _;
        this._board = board != null ? board : (function() {
          var _i, _results;
          _results = [];
          for (_ = _i = 0; _i <= 8; _ = ++_i) {
            _results.push(tictactoe.Mark.EMPTY);
          }
          return _results;
        })();
      }

      Board.prototype.isEmpty = function() {
        return this._board.every(function(s) {
          return s === tictactoe.Mark.EMPTY;
        });
      };

      Board.prototype.isFull = function() {
        return this._board.every(function(s) {
          return __indexOf.call(tictactoe.Mark.VALID_MARKS, s) >= 0;
        });
      };

      Board.prototype.getSquare = function(index) {
        if (!((0 <= index && index <= 8))) {
          throw new RangeError;
        }
        return this._board[index];
      };

      Board.prototype.move = function(index, mark) {
        if (!((0 <= index && index <= 8))) {
          throw new RangeError;
        }
        if (!(__indexOf.call(tictactoe.Mark.VALID_MARKS, mark) >= 0)) {
          throw new Error("Invalid mark");
        }
        return this._board[index] = mark;
      };

      Board.prototype.getPossibleMoves = function() {
        var i, mark, _i, _len, _ref, _results;
        _ref = this._board;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          mark = _ref[i];
          if (mark === tictactoe.Mark.EMPTY) {
            _results.push(i);
          }
        }
        return _results;
      };

      Board.prototype.getWinnerMarkAndWinPosition = function() {
        var i, j, k, winPosition, _i, _len, _ref, _ref1, _ref2, _ref3;
        _ref = Board.WIN_POSITIONS;
        for (winPosition = _i = 0, _len = _ref.length; _i < _len; winPosition = ++_i) {
          _ref1 = _ref[winPosition], i = _ref1[0], j = _ref1[1], k = _ref1[2];
          if (((this._board[i] === (_ref3 = this._board[j]) && _ref3 === (_ref2 = this._board[k])) && _ref2 !== tictactoe.Mark.EMPTY)) {
            return [this._board[i], winPosition];
          }
        }
        return [tictactoe.Mark.EMPTY, -1];
      };

      Board.prototype.isGameOver = function() {
        var winnerMark, _, _ref;
        _ref = this.getWinnerMarkAndWinPosition(), winnerMark = _ref[0], _ = _ref[1];
        return winnerMark !== tictactoe.Mark.EMPTY || (winnerMark === tictactoe.Mark.EMPTY && this.isFull());
      };

      Board.prototype.clone = function() {
        return new Board(this._board.slice(0));
      };

      return Board;

    })();
  });

  namespace('tictactoe', function(exports) {
    var AI;
    return exports.AI = AI = (function() {
      function AI() {}

      AI.MAX_DEPTH = 999;

      AI.getBestMove = function(playerMark, board) {
        var bestMove, score, _ref;
        if (board.isEmpty()) {
          return tictactoe.helpers.randomChoice([0, 1, 2, 3, 4, 5, 6, 7, 8]);
        } else {
          _ref = this._negamax(board, this.MAX_DEPTH, -Infinity, Infinity, playerMark), score = _ref[0], bestMove = _ref[1];
          return bestMove;
        }
      };

      AI._negamax = function(board, depth, alpha, beta, playerMark) {
        var bestMove, move, newBoard, opponentMark, score, _i, _len, _ref;
        if (board.isGameOver() || depth === 0) {
          return [this._getScore(playerMark, board), null];
        }
        bestMove = null;
        _ref = board.getPossibleMoves();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          move = _ref[_i];
          newBoard = board.clone();
          newBoard.move(move, playerMark);
          opponentMark = tictactoe.Mark.getOpponent(playerMark);
          score = -(this._negamax(newBoard, depth - 1, -beta, -alpha, opponentMark)[0]);
          if (score >= beta) {
            return [score, move];
          }
          if (score > alpha) {
            alpha = score;
            bestMove = move;
          }
        }
        return [alpha, bestMove];
      };

      AI._getScore = function(mark, board) {
        var opponentMark, winnerMark, _, _ref;
        opponentMark = tictactoe.Mark.getOpponent(mark);
        _ref = board.getWinnerMarkAndWinPosition(), winnerMark = _ref[0], _ = _ref[1];
        if (winnerMark === mark) {
          return Infinity;
        }
        if (winnerMark === opponentMark) {
          return -Infinity;
        }
        if (board.isFull()) {
          return 0;
        }
      };

      return AI;

    })();
  });

  namespace('tictactoe', function(exports) {
    var Game;
    return exports.Game = Game = (function() {
      function Game(player1, player2) {
        this.gameStarted = new tictactoe.Event();
        this.playerChanged = new tictactoe.Event();
        this.boardChanged = new tictactoe.Event();
        this.gameOver = new tictactoe.Event();
        this.isAIMoving = false;
        this.restart(player1, player2);
      }

      Game.prototype.restart = function(player1, player2) {
        if (!(__indexOf.call(tictactoe.Player.VALID_PLAYERS, player1) >= 0)) {
          throw new Error("Invalid player1");
        }
        if (!(__indexOf.call(tictactoe.Player.VALID_PLAYERS, player2) >= 0)) {
          throw new Error("Invalid player2");
        }
        this._board = new tictactoe.Board();
        this._players = [player1, player2];
        this._board = new tictactoe.Board();
        this._turn = 0;
        this.gameStarted.raise(this);
        this.boardChanged.raise(this, [this._board]);
        this.playerChanged.raise(this, [this._getCurrentMark()]);
        if (this._getCurrentPlayer() === tictactoe.Player.COMPUTER) {
          return this._autoMove();
        }
      };

      Game.prototype.move = function(index) {
        var winPosition, winnerMark, _ref;
        if (this._board.isGameOver() || this._board.getSquare(index !== tictactoe.Mark.EMPTY)) {
          return;
        }
        this._board.move(index, this._getCurrentMark());
        this.boardChanged.raise(this, [this._board]);
        _ref = this._board.getWinnerMarkAndWinPosition(), winnerMark = _ref[0], winPosition = _ref[1];
        if (this._board.isGameOver()) {
          return this.gameOver.raise(this, [winnerMark, winPosition]);
        } else {
          this._turn += 1;
          this.playerChanged.raise(this, [this._getCurrentMark()]);
          if (this._getCurrentPlayer() === tictactoe.Player.COMPUTER) {
            return this._autoMove();
          }
        }
      };

      Game.prototype._autoMove = function() {
        var _this = this;
        this.isAIMoving = true;
        return setTimeout((function() {
          var bestMove, currentMark;
          currentMark = tictactoe.Mark.VALID_MARKS[_this._turn % 2];
          bestMove = tictactoe.AI.getBestMove(currentMark, _this._board);
          _this.move(bestMove);
          return _this.isAIMoving = false;
        }), 1000);
      };

      Game.prototype._getCurrentPlayer = function() {
        return this._players[this._turn % 2];
      };

      Game.prototype._getCurrentMark = function() {
        return tictactoe.Mark.VALID_MARKS[this._turn % 2];
      };

      return Game;

    })();
  });

  namespace('tictactoe', function(exports) {
    var UI;
    return exports.UI = UI = (function() {
      function UI(_game, _boardContext, _statusContext) {
        this._game = _game;
        this._boardContext = _boardContext;
        this._statusContext = _statusContext;
        this._drawBoard = __bind(this._drawBoard, this);
        this._onGameOver = __bind(this._onGameOver, this);
        this._onBoardChanged = __bind(this._onBoardChanged, this);
        this._onPlayerChanged = __bind(this._onPlayerChanged, this);
        this._onGameStarted = __bind(this._onGameStarted, this);
        this._onBoardClick = __bind(this._onBoardClick, this);
        this._boardSquare = this._boardContext.find('#board-square');
        this._boardContext.click(this._onBoardClick);
        this._game.gameStarted.add(this._onGameStarted);
        this._game.playerChanged.add(this._onPlayerChanged);
        this._game.boardChanged.add(this._onBoardChanged);
        this._game.gameOver.add(this._onGameOver);
      }

      UI.prototype._onBoardClick = function(e) {
        var index, x, y;
        x = e.pageX - this._boardSquare.offset().left;
        y = e.pageY - this._boardSquare.offset().top;
        if (x > 0 && y > 0 && !this._game.isAIMoving) {
          index = this._getIndex(x, y);
          return this._game.move(index);
        }
      };

      UI.prototype._getIndex = function(x, y) {
        var boardColumns, height, i, iX, iY, squareLength, width;
        width = this._boardContext.width();
        height = this._boardContext.height();
        boardColumns = 3;
        squareLength = Math.min(width, height / boardColumns);
        iX = Math.floor(x / squareLength);
        iY = Math.floor(y / squareLength);
        return i = iX + iY * boardColumns;
      };

      UI.prototype._onGameStarted = function() {
        return this._updateStatusBar('');
      };

      UI.prototype._onPlayerChanged = function(sender, _arg) {
        var mark;
        mark = _arg[0];
        return this._updateStatusBar("It's " + (tictactoe.Mark.toString(mark)) + "'s turn");
      };

      UI.prototype._onBoardChanged = function(sender, _arg) {
        var board;
        board = _arg[0];
        return this._drawBoard(board);
      };

      UI.prototype._onGameOver = function(sender, _arg) {
        var winPosition, winnerMark;
        winnerMark = _arg[0], winPosition = _arg[1];
        if (winnerMark !== tictactoe.Mark.EMPTY) {
          this._drawStrike(winPosition);
          return this._updateStatusBar("" + (tictactoe.Mark.toString(winnerMark)) + " wins!");
        } else {
          return this._updateStatusBar("Tied game");
        }
      };

      UI.prototype._drawBoard = function(board) {
        var i, mark, _i, _results;
        this._boardContext.find('use[id^="O"], use[id^="X"], use[id^="strike"]').hide();
        _results = [];
        for (i = _i = 0; _i <= 8; i = ++_i) {
          mark = board.getSquare(i);
          if (mark !== tictactoe.Mark.EMPTY) {
            _results.push(this._boardContext.find("#" + (tictactoe.Mark.toString(mark) + i)).show());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      UI.prototype._drawStrike = function(winPosition) {
        return this._boardContext.find("#strike" + winPosition).show();
      };

      UI.prototype._updateStatusBar = function(text) {
        return this._statusContext.text(text);
      };

      return UI;

    })();
  });

}).call(this);
